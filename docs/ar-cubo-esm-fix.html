<!doctype html>
<html lang="pt-br">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>AR do Cubo (ESM + Fix + Debug)</title>
  <style>
    html,body { height:100%; margin:0; font-family:system-ui, Segoe UI, Roboto, Arial; background:#fff; }
    header { padding:12px 16px; border-bottom:1px solid #eee; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    header h1 { font-size:16px; margin:0; font-weight:700; }
    #wrap { display:grid; grid-template-rows:auto 1fr auto; height:calc(100% - 56px); }
    model-viewer { width:100%; height:100%; --poster-color:#fff; }
    footer { text-align:center; font-size:12px; color:#666; padding:8px 0; border-top:1px solid #eee; }
    .btn { appearance:none; border:1px solid #ddd; background:#fafafa; padding:6px 10px; border-radius:10px; cursor:pointer; font-weight:600; }
    .cta { font-weight:700; }
    #status { font-size:12px; color:#666; }
    #log { white-space:pre-wrap; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; font-size:12px; padding:8px; border-top:1px solid #eee; color:#333; background:#fafafa; }
  </style>
  <!-- model-viewer (module) -->
  <script type="module" src="https://cdn.jsdelivr.net/npm/@google/model-viewer@4.0.0/dist/model-viewer.min.js"></script>
</head>
<body>
  <header>
    <h1>AR do Cubo (ESM + Fix)</h1>
    <span id="status">Preparando…</span>
    <button id="btnDownload" class="btn" style="margin-left:auto; display:none">Baixar modelo</button>
  </header>

  <div id="wrap">
    <model-viewer id="mv"
      ar ar-modes="webxr scene-viewer quick-look"
      camera-controls
      tone-mapping="neutral"
      shadow-intensity="0.8"
      exposure="1.0">
      <button slot="ar-button" class="cta">Ver em AR</button>
    </model-viewer>
    <div id="log"></div>
    <footer>HTTPS é necessário para AR. iOS Quick Look exige .usdz (não incluso neste teste).</footer>
  </div>

  <script type="module">
    const logEl = document.getElementById('log');
    const statusEl = document.getElementById('status');
    const mv = document.getElementById('mv');
    const btnDownload = document.getElementById('btnDownload');

    function log(...args){
      console.log(...args);
      try { logEl.textContent += args.map(a => (typeof a==='object'? JSON.stringify(a) : String(a))).join(' ') + "\\n"; } catch(e){}
    }

    log('Iniciando módulo… UA:', navigator.userAgent);

    const base = 'https://cdn.jsdelivr.net/npm/three@0.160.0';
    const THREE = await import(`${base}/build/three.module.js`);
    const { GLTFExporter } = await import(`${base}/examples/jsm/exporters/GLTFExporter.js`);
    log('Three importado. Version keys:', Object.keys(THREE).slice(0,8), '…');
    log('GLTFExporter typeof:', typeof GLTFExporter);

    // Cena mínima com luz suportada
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    const size = 1.0;
    const geo = new THREE.BoxGeometry(size, size, size);
    const faceColors = [0xFF5252,0xFFEA00,0x69F0AE,0x40C4FF,0xFFAB40,0xB388FF];
    const mats = faceColors.map(c => new THREE.MeshStandardMaterial({ color:c, roughness:.6, metalness:.05 }));
    const cube = new THREE.Mesh(geo, mats);
    scene.add(cube);
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(3,4,5);
    const target = new THREE.Object3D();
    target.position.set(0,0,-1);
    dir.add(target);
    dir.target = target;
    scene.add(dir);
    log('Cena pronta: cubo + dirLight.');

    // Exportar: se vier JSON, salvar como .gltf; se vier ArrayBuffer, salvar como .glb
    statusEl.textContent = 'Exportando…';
    const exporter = new GLTFExporter();

    function toBlobUrl(data) {
      let blob, name;
      if (data instanceof ArrayBuffer) {
        blob = new Blob([data], { type:'model/gltf-binary' });
        name = 'cubo.glb';
      } else if (typeof data === 'object') {
        const json = JSON.stringify(data);
        blob = new Blob([json], { type:'model/gltf+json' });
        name = 'cubo.gltf';
      } else {
        const txt = String(data);
        blob = new Blob([txt], { type:'text/plain' });
        name = 'export.txt';
      }
      const url = URL.createObjectURL(blob);
      return { url, name, blob };
    }

    try {
      exporter.parse(scene, (result) => {
        const typeInfo = (result && result.constructor && result.constructor.name) || typeof result;
        const bytes = (result && result.byteLength) ? result.byteLength : -1;
        log('Export result type:', typeInfo, 'byteLength:', bytes);

        const { url, name, blob } = toBlobUrl(result);
        log('Blob URL:', url, 'filename:', name, 'size:', blob.size, 'type:', blob.type);

        // Carregar no model-viewer apenas se for GLB (binário). Se for GLTF (JSON), ainda funciona, mas alguns navegadores exigem arquivos externos .bin — aqui não há, pois é minimalista.
        mv.src = url;
        statusEl.textContent = 'Modelo pronto. Toque em “Ver em AR”.';

        // Baixar
        btnDownload.style.display = 'inline-block';
        btnDownload.onclick = () => {
          const a = document.createElement('a');
          a.href = url;
          a.download = name;
          a.click();
        };
      }, { binary: true, embedImages: true });

    } catch (e) {
      console.error('Erro na exportação:', e);
      log('Erro na exportação:', String(e));
      statusEl.textContent = 'Falha na exportação.';
    }

    // Eventos do model-viewer
    mv.addEventListener('load', () => log('model-viewer: load (modelo carregado).'));
    mv.addEventListener('ar-status', (e) => log('model-viewer: ar-status = ' + e.detail.status));
    mv.addEventListener('error', (e) => log('model-viewer: error = ' + (e.message || JSON.stringify(e))));
  </script>
</body>
</html>
